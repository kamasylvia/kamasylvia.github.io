{"posts":[{"title":"[Development] - Roadmap","content":"Introduction These images are from roadmap.sh Frontend Backend DevOps ","link":"https://www.kamasylvia.com/post/development-roadmap/"},{"title":"[Dapr] - gRPC with Pub/Sub","content":"前言 我在 components 配置文件夹下写了 pubsub.yaml 但是在 gRPC 服务中未使用发布订阅。在启动服务的时候报错 正文 这是因为 dapr 认为我们的 gRPC 服务使用了发布订阅，但是没有重写 ListTopicSubscriptions 方法。解决方案就是在服务中重写 ListTopicSubscriptions。 或者不使用含有 pubsub.yaml 的 components-path 最后别忘了在 startup 中注册服务 ","link":"https://www.kamasylvia.com/post/dapr-grpc-with-pubsub/"},{"title":"[WebAPI] - 枚举类型和字符串相互转换","content":"前言 我们想要一个数据在传递请求和应答的 json 时是 string 类型，在存储时是 enum 类型。 正文 首先创建一个枚举类型 再创建一个实体类 然后创建请求类 最后创建应答类 AutoMapper 配置 Startup.cs 配置 ","link":"https://www.kamasylvia.com/post/webapi-convert-enum2string/"},{"title":"[WebAPI] - 全局异常处理","content":"前言 全局异常处理可以有效中断程序并返回自定义格式的报错样式。常用方法是通过筛选器 (ExceptionFilter) 或中间件 (app.UseExceptionHandler)。官方文档是推荐用中间件，但个人喜欢用筛选器。 正文 在项目中新建 Infrastructure 文件夹。如已存在则跳过。 在 Infrastructure 下新建 Exceptions、ActionResults 和 Filters 两个文件夹。如已存在则跳过。 在 Infrastructure/Exceptions/ 下创建自定义异常的基类和其他子类。这样做是为了编写的时候可以让 IDE 根据父类快速创建子类的构造函数。 在 Infrastructure/ActionResult/ 下创建返回结果的样式： 在 Infrastructure/Filters/ 下创建自定义的异常筛选器。示例中为了给未来可能添加的 await 方法做预留，重写 OnExceptionAsync 却执行同步方法。如果确定没有异步方法，重写 OnException 即可。 在 Startup.cs 中注册全局异常处理： 参考 ASP.NET Core 中的筛选器 | Microsoft Docs .net5 - 创建Web.Api项目（五）异常过滤器【自定义异常/统一异常处理】 - gygtech - 博客园 ASP.NET Core搭建多层网站架构【11-WebApi统一处理返回值、异常】 - kasnti - 博客园 ","link":"https://www.kamasylvia.com/post/webapi-exception-filter/"},{"title":"[WebAPI] - 自动依赖注入","content":"前言 .NET Core 自带 DI（包括Autofac）的常规用法：每写一个接口就需要注册一次，以备在使用时自动注入实例。在写常规代码时这样重复的步骤过于繁琐。 批量注入依赖一般是用 Autofac 实现的，方法是 这里介绍一种使用 .NET Core DI 实现自动依赖注入的方法。。 正文 创建自定义特性： 给接口实现类添加该属性，并定义生命周期 创建 IServiceCollection 的扩展方法： 在 Startup.cs 中批量注入： 需要额外配置的依赖不要自动注入，只需要在第二步不在实现类上标注 [CustomDependency] 特性，然后在 Startup.cs 中用默认 DI 手动注入即可。例如： 参考 深入浅出依赖注入容器——Autofac - CharyGao - 博客园 .net core 批量注入（自带DI，AutoFac） - willardzmh - 博客园 ","link":"https://www.kamasylvia.com/post/webapi-automated-dependancy-injection/"},{"title":"[DevOps] - 自动格式化代码并推送回远程仓库","content":"前言 每个程序员的代码风格都不一样，为了大括号要不要另起一行甚至能发动圣战。因此，保持远程仓库的风格一致性是很有必要的，也是 CI 的基本功能之一。本篇继续使用 Azure DevOps Pipelines 进行 CI 配置。 正文 本文使用的 formatter 是 csharpier，用于格式化 .NET 项目。其他语言的配置请自行摸索 用 CSharpier 格式化 .NET 项目 打开 Azure DevOps Pipelines (之后统称 pipelines) 的配置文件 azure-pipelines.yml 编辑界面，右边选择 “.Net Core” 安装 csharpier 这里左边红框内是右边填写完后点击 Add 生成的配置代码。 格式化指令 将格式化后的代码推送回远程仓库。 完整配置 azure-pipelines.yml: Build.SourceBranchName 是预定义变量，表示触发 CI 的分支名。 完整代码 参考 Predefined variables - Azure Pipelines | Microsoft Docs Run Git commands in a script - Azure Pipelines | Microsoft Docs Build Azure Repos Git repositories - Azure Pipelines | Microsoft Docs ","link":"https://www.kamasylvia.com/post/devops-auto-format/"},{"title":"[DevOps] - 从 GitHub 自动构建镜像到 DockerHub ","content":"前文 DockerHub 的自动构建（Automated Builds）功能自 2021 年 6 月 18 日之后，仅限付费用户使用。因此我们需要寻找替代品去完成从 GitHub 仓库自动构建镜像并推送到 DockerHub 的功能。网上比较流行的方式是用 Github Actions，但关于使用 docker-compose 编排但项目进行批量构建推送的方案稀缺（我没找到）。此篇记录下使用 Azure DevOps 来实现自动构建的方案。 正文 先参考这篇教程 【Azure + Core】实现CI/CD（一）构建镜像并推送仓库 准备账号和连接服务。在第三步的新建 Pipeline 中，因为我们用的是 docker-compose 而不是 docker ，在配置 YAML 文件时有些不同。 在进入 YAML 编辑界面后，删除 docker 的配置，然后点击右上角的 &quot;Show assistant&quot;。 搜索框输入 &quot;docker&quot;，选择 &quot;Docker Compose&quot; 然后参照官方文档 Docker Compose任务 进行先构建后推送的配置。 Build service images: Container Registry Type: Container Registry Docker Registry Service Connection: The service connection we created. Docker Compose File: **/docker-compose.yml Additional Docker Compose Files: docker-compose.override.yml Environment Variables: blank Project Name: default Qualify Image Names: true Action: Build service images Include Source Tags: false Include Latest Tag: true Arguments: blank Advanced Options: Docker Host Service Connection: blank No-op if no Docker Compose File: true Require Additional Docker Compose Files: false Working Directory: default Docker Compose executable Path: blank 重复上一步，Action 选择 Push service images 进行推送配置，或直接复制粘贴之前生成的 YAML 配置代码，并删掉 Addtitional Docker Compose Files。注意：构建和推送配置唯一的不同就是 Additional Docker Compose Files。 Push service images Container Registry Type: Container Registry Docker Registry Service Connection: The service connection we created. Docker Compose File: **/docker-compose.yml Additional Docker Compose Files: blank Environment Variables: blank Project Name: default Qualify Image Names: true Action: Build service images Include Source Tags: false Include Latest Tag: true Arguments: blank Advanced Options: Docker Host Service Connection: blank No-op if no Docker Compose File: true Require Additional Docker Compose Files: false Working Directory: default Docker Compose executable Path: blank 完整 YAML 配置代码。如果 Azure DevOps 没有对这块进行更新，其实可以直接复制粘贴这段而不用去 &quot;Show assisstant&quot; 里繁琐的配置。 ","link":"https://www.kamasylvia.com/post/devops-automated-build-from-github-to-dockerhub/"},{"title":"[六孔膜笛] - 每日训练（萌新篇）","content":"前言 参考的是画帛乐团张玉坤小姐姐的 零基础学会竹笛 看这个视频就够（第三集） 系列 正文 长音练习 要求 丹田运气 用最大的力气吹，吹最响 能吹多长吹多长，吹平稳 练习音阶 筒音作5（sol）的16音。 （低音区sol la si；中音区do re mi fa sol la si；高音区do re mi fa sol la.） 上行16音➕下行16音=32个音32口气。每一口气都按照3个要求去练习。 吐音练习 要求 均匀 清楚 颗粒性强 初阶段慢练 练习音阶 筒音作5（sol）的16音。 （低音区sol la si；中音区do re mi fa sol la si；高音区do re mi fa sol la.） 每个音吹完单吐8组和双吐8组后再换音。 上行16音➕下行16音=32个音。每个音都按照4个要求去练。 ","link":"https://www.kamasylvia.com/post/flute-daily-practice/"},{"title":"[C#] - Async/Await inside Linq","content":"前言 在 Linq 方法内使用 async/await 会报错的 async/await inside LINQ where clause not working 正文 首先要 Nuget 引入 System.Linq.Async.Queryable 包。 注意 引入 System.Linq.Async 后会导致某些原来的 Linq 语法报错，这时候加上 ToAsyncEnumerable() 或 ToAsyncQueryable() 即可。 只对 C# 8.0 以上版本有效。 ","link":"https://www.kamasylvia.com/post/c-asyncawait-inside-linq/"},{"title":"[Dapr] - VSCode 开发环境搭建","content":"前言 本文转载自 Dapr微服务应用开发系列1：环境配置 正文 如果不想在本机安装 Dapr 的 CLI 和 Runtime，还可以利用 Visual Studio Code Remote - Containers 的强大功能来实现开发环境的容器化。 Dapr为各种支持的开发语言默认提供了开发容器，方便你把任何项目转换为Dapr应用。 大致步骤如下： 创建项目，（可选）引用对应语言的Dapr SDK 在VS Code中打开项目的工作区（Workspace） 在命令面板中输入 Remote-Containers: Add Development Container Configuration Files... 在选择开发容器的时候，输入dapr 来进行查找，选择对应的语言版本，比如 Dapr with C# VS Code 会自动给你的项目添加相关的 Dockerfile 和其他配置文件（比如 .devcontainer 文件夹） VS Code 检测到 .devcontainer 文件夹后，会提示你是否要使用容器模式打开 通过容器模式打开后，会自动构建项目工作区的容器镜像，同时还会额外启动用于容器开发的 placement 和 zipkin 容器实例（名称为：dapr_placement_dapr-dev-container 和 dapr_zipkin_dapr-dev-container） 开发容器如下图所示： 使用这种开发容器带来的好处就是：整个 Dapr 开发的依赖环境可以通过 Dockerfile 来自动配置完成。 ","link":"https://www.kamasylvia.com/post/dapr-vscode-environment/"},{"title":"[Dapr] - Deploy Dapr on a Kubernetes cluster","content":"前言 此文参照官方教程进行安装。记录下踩过的坑和解决方法。 正文 前置要求 安装 kubectl 这个不需要安装的，Docker for Mac 自带了 kubectl，只要进设置开启 Kubernates 即可。 安装 Dapr CLI 用 Homebrew 安装 可能遇到的问题 解决方法 开启终端代理解决，方法是点击 ClashX 的 “复制终端代理命令”，再去终端黏贴，然后再次尝试安装。 使用 Dapr CLI 安装 Dapr 安装命令 可能遇到的问题 或 或 解决方法 或 确认安装 命令 输出 ","link":"https://www.kamasylvia.com/post/dapr-deploy-dapr-on-a-kubernetes-cluster/"},{"title":"[WebAPI] - Swagger 添加注释","content":"前言 .NET 5 的 WebAPI 项目自带 Swagger，但默认不显示注释，我们需要手动配置一下。 正文 生成 XML 文件 用 VS 或 VS for Mac 右键项目-&gt;选项-&gt;编译器-&gt;勾选“生成 XML 文档”。 默认路径在 bin\\Debug\\netX.X\\ 下。 如果是用 VSCode，手动编辑项目 .csproj 文件，添加 配置 XML 路径 编辑 StartUp.cs 注意 System.Reflection.Assembly.GetExecutingAssembly().Location 返回的是 .dll 文件路径。 Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) 返回的是 .dll 文件所在目录，也就是生成 XML 时的默认路径 bin\\Debug\\netX.X\\。 Directory.GetCurrentDirectory() 获取的是 .csproj 所在目录。 如果使用其他路径，请手动填写 c.IncludeXmlComments() 方法的参数。 调试运行 开发模式下启动项目，进入 Swagger 页面，即可看到用三斜杠 /// 注释的内容。 注意 Swagger 只允许在开发模式下访问，生产模式下不可用。 三斜杠 /// 是 XML 注释，只有 XML 注释才能在 Swagger 中显示。双斜杠 // 注释不显示在 Swagger 中。 Swagger 只显示 &lt;summary&gt; 内容 &lt;/summary&gt; 中的内容。 ","link":"https://www.kamasylvia.com/post/webapi-swagger-comment/"},{"title":"[WebAPI] - Mapping string to enum and vice versa","content":"前言 枚举类型在 .NET 中默认是整型，前端传入一般是字符串，这里需要做些简单的转换。 正文 ","link":"https://www.kamasylvia.com/post/webapi-mapping-string-to-enum-and-vice-versa/"},{"title":"[WebAPI] - List of enums in EF Core","content":"前言 对于 IEnumerable&lt;enum&gt; 的属性，EF Core 无法储存。 这里介绍一种解决方案。 正文 参考资料 值转换 - MS Docs List of enums in EF Core - StackOverFlow ","link":"https://www.kamasylvia.com/post/webapi-list-of-enums-in-ef-core/"},{"title":"[六孔膜笛] - 零基础菜鸟自学视频资料","content":"前言 此文收录哔哩哔哩上的自学材料，适合零基础初学者。 正文 心竹笛工作室 心竹笛工作室的《笛子各式各样的小问题》系列适合还没买笛子和没学会贴膜的纯萌新。 新爱琴 新爱琴的教程适合学会贴膜以后的萌新，可以说是网上最细致的教程了，强烈推荐！！！ 画帛乐团 这位小姐姐上过央视，实力毋庸置疑，还能边学习边看美女。 张维良 当代笛神，大师教你如何吹笛。 ","link":"https://www.kamasylvia.com/post/flute/"},{"title":"[真会C#？] - 事件","content":"事件 广播和订阅 使用委托的时候，通常会出现两个角色，一个广播者，一个订阅者。 广播者这个类型包含一个委托字段，广播者通过调用委托来决定什么时候进行广播。 订阅者是方法目标的接收者，订阅者可以决定何时开始或结束监听，方式是通过在委托上调用 += 和 -=。 一个订阅者不知道和不干扰其他的订阅者。 Event 事件 事件就是将上述模式正式化的一个语言特性。 事件是一种结构，为了实现广播者/订阅者模型，它只暴露了所需的委托特性的部分子集。 事件的主要目的是防止订阅者之间相互干扰。 声明事件 最简单的声明事件的方式就是在委托前面加上 event 关键字。 例子： 事件在内部是如何工作的？ 首先，编译器把事件的声明翻译成类似下面的代码： add 和 remove 关键字代表着显式的事件访问器，有点像属性访问器。 然后编译器会查看 Broadcaster 内部对 PriceChanged 的引用，如果不是 += 或 -= 的操作，那就直接把它们定向到底层的委托字段 priceChanged。 第三点，编译器把作用在 event 上的 += 和 -= 操作翻译成调用 add 或 remove 访问器。 定义事件 标准的事件模式 为编写事件，.NET 定义了一个标准的模式。 System.EventArgs，一个预定义的框架类，除了静态的 Empty 属性之外，它没有其他成员。 EventArgs 是为了事件传递信息的类的基类。 通常是根据所含有的信息进行命名，而不是所使用的事件。 通常通过属性或只读字段来暴露数据。 为事件选择或定义委托。 返回类型是 void。 接收两个参数，第一个参数是 object，第二个参数是 EventArgs 的子类。第一个参数表示事件的广播者，第二个参数包含需要传递的信息。 名称必须以 EventHandler 结尾。 Framework 定义了一个泛型委托 System.EventHandler&lt;T&gt;，它满足上述规则。 针对选择的委托定义事件 可触发事件的方法 方法的可访问性必须是 protected virtual。 方法名必须和事件一致，前面加上 On，接收一个 EventArgs 参数。 完整的例子 调用事件 多线程的场景下，你需要在测试或调用前，把委托赋给一个临时变量，来避免线程安全相关的错误： 在 C#6 之后，也可以这样写： 非泛型的 EventHandler 当事件不携带多余信息的时候，可以使用非泛型的 EventHandler 委托。 传递 EventArgs.Empty 属性。 事件访问器 事件访问器是事件的 += 和 -= 函数的实现。 编译器会把它转化为： 一个私有的委托字段。 一对公共的事件访问器函数（add_PriceChanged 和 remove_PriceChanged），这两个函数的实现会把 += 和 -= 操作交给私有的委托字段。 也可以显式的定义事件访问器。 显式定义的事件访问器 当事件访问器仅仅是另一个广播事件的类的中继。 当类暴露大量 event，但是大部分时候都只有少数的订阅者存在。 显式实现一个声明了事件的接口。 事件修饰符 virtual：可以被重写。 abstract sealed static ","link":"https://www.kamasylvia.com/post/csharp-tutoril-events/"},{"title":"[真会C#?] - 委托","content":"上集 Delegates 委托 委托是一个对象，它知道如何调用一个方法。 委托类型和委托实例 委托类型定义了委托实例可以调用的那类方法，具体来说，委托类型定义了方法的返回类型和参数。 把方法赋值给委托变量的时候就创建了委托实例： 调用： 委托实例其实就是调用者的委托：调用者调用委托，然后委托调用目标方法。 间接的把调用者和目标方法解耦合了。 简写 完整写法： 简写： 编写插件式方法 方法是在运行时才赋值给委托变量的。 多播委托 所有的委托实例都具有多播的能力。一个委托实例可以引用一组目标方法。 + 和 += 操作符可以合并委托实例。 调用 d 就会调用 SomeMethod1 和 SomeMethod2。 委托的调用顺序与他们的定义顺序一致。 - 和 -= 会把右边的委托实例从左边的委托变量里移除。 委托变量使用 + 或 += 操作符时，其操作数可以是 null。就相当于把一个新的值赋给了委托变量。 相当于 对单个目标方法的委托变量使用 -= 操作符时，就相当于把 null 值赋给了委托变量。 委托是不可变的。 使用 =+ 或 -= 操作符时，实际上时创建了新的委托实例，并把它赋给了当前的委托变量。 如果多播委托的返回类型不是 void，那么调用者从最后一个被调用的方法来接收返回值。当前的方法仍然会被调用，但是其返回值就被弃用了。 所有的委托类型都派生于 System.MulticastDelegate，而它又派生于 System.Delegate。 C# 会把作用于委托的 +, -, +=, -= 操作编译成使用 System.Delegate 的 Combine 和 Remove 两个静态方法。 下集 实例方法目标和静态方法目标 当一个实例方法 被赋值给委托对象的时候，这个委托对象不仅要保留着对方法的引用，还要保留着方法所属实例的引用。 System.Delegate 的 Target 属性就代表着这个实例。 如果引用的是静态方法，那么 Target 属性的值就是 null。 泛型委托类型 委托类型可以包括泛型类型参数 Func 和 Action 委托 使用泛型委托，就可以写出这样一组委托类型，它们可调用的方法可以拥有任意的返回类型和任意（合理）数量的参数。 System 命名空间 例子： 委托 vs 接口 委托可以解决的问题，接口都可以解决。 什么情况下更适合使用委托而不是接口呢？当下列条件之一满足时： 接口只能定义一个方法。 需要多播能力。 订阅者需要多次实现接口。如下列这种情况就更适合使用委托。 委托的兼容性 委托类型 委托类型之间互不相容，即使方法签名一样： 委托实例 如果委托实例拥有相同的方法目标，那么委托实例就认为是相等的。 委托参数 当你调用一个方法时，你提供的参数（argument）可以比方法的参数（parameter）定义更具体。 委托可以接受比它的方法目标更具体的参数类型，这个叫 委托逆变 ContraVariance。 返回类型 调用方法时，你可以得到一个比请求的类型更具体的类型的返回结果。 委托的目标方法可以返回比委托描述里更具体的类型的返回结果， 这就叫 委托协变 Covariance。 泛型委托类型参数的可变性 Covariance, out ContraVariance, in ","link":"https://www.kamasylvia.com/post/csharp-tutorial-delegates/"},{"title":"[OneDrive] 免费获得 5T - 25T OneDrive 空间","content":"Microsoft 365 开发人员中心 开发人员计划 - Microsoft 365 Microsoft 365 E5 开发者账号申请 免费申请Microsoft 365 E5开发者订阅教程 Microsoft 365 E5 开发者账号续订 E5 自动订阅程序[已开源] ","link":"https://www.kamasylvia.com/post/microsoft365/"},{"title":"[真会C#?] Type - 结构体","content":"文档资料 真会C#？- 第3章 创建类型（完结，泛型部分单独出视频） C# 文档] 结构体 struct 和 class 差不多，但是有一些不同： struct 是值类型，class 是引用类型。 struct 不支持继承（除了隐式的继承了 object，具体点就是 System.ValueType） class 能有的成员，struct 也可以有，但是以下几个不行： 无参构造函数。 字段初始化器。 析构函数。 virtual 或 protected 成员。 struct 有一个无参的构造函数，但是你不能对其进行重写。他会对字段进行按位归零操作。 当你定义 struct 构造函数的时候，必须显式的为每个字段赋值。 不可以有字段初始化器。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-struct/"},{"title":"[真会C#?] Type - 枚举","content":"文档资料 真会C#？- 第3章 创建类型（完结，泛型部分单独出视频） C# 文档 枚举 枚举是一个特殊的值类型，它可以让你指定一组命名的数值常量。 枚举的底层原理 每个媒体都对应一个底层的整形数值（Enum.GetUnderlyingType()）。默认： 是 int 类型。 会按照枚举成员的声明顺序自动赋值：0, 1, 2, ... 也可以指定其他的类型作为枚举的整数类型，例如 byte： public enum BorderSide : byte { Left, Right, Top, Bottom } 也可以单独指定枚举成员对应的整数值： public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 } 也可以只指定其中某些成员的数值，未被赋值的成员，将接着他前面已赋值成员的值递增。 枚举的转换 枚举可以显式的和其底层的数值相互转换。 在枚举表达式里，0 数值会被编译器特殊对待，它不需要显式的转换： 因为枚举的第一个成员通常被当做默认值，他的值默认就是 0。 组合枚举里，0 表示没有标志（flags）。 Flags enum 组合枚举 Flags enum 可以对枚举的成员进行组合。 为为了避免歧义，枚举的成员需要显式的赋值，典型的就是使用二的乘幂。 Flags enum 可以使用位操作符，例如 | 和 &amp;。 Flags enum 底层原理 Flags 属性 按约定，如果每组成员可以组合的话，[flags] 属性就应该应用在枚举类型上。 如果声明了这样的枚举却没有使用 [flags] 属性，你你仍然可以组合枚举的成员，但是调用枚举实例的 ToString() 方法时，输出的将是一个数值而不是一组名称。 按约定，可组合枚举的命名应该是复数的（以 s 结尾）。 枚举支持的操作符 =、==、!=、&lt;、&gt;、&lt;=、&gt;=、+、-、^、&amp;、|、~、+=、-=、++、--、sizeof 其中按位的、比较的、算数的操作符返回的都是处理底层值后得到的结果。 加法操作只允许一个枚举和一个整型数值相加，两个枚举相加是不可以的。 类型安全的问题 超过枚举的最大范围后虽然不报错，但失去了使用枚举的意义。 检查枚举值的合理性：Enum.IsDefined() 静态方法。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-enum/"},{"title":"[真会C#?] Type - 类型","content":"文档资料 真会C#？- 第1-2章 简介和基础（完结） C# 编程指南 C# 语言规范 类型 类型定义了一个值的蓝本。 变量是一个存储位置，它在不同时期可能包含不同的值。 常量永远表示相同的值。 C# 里所有的值都是类型的实例。值的含义，变量可能拥有的值是什么，都由它的类型决定。 内置类型 System 命名空间 除了 decimal 之外的内置类型叫做原始类型。 通过指令，在编译的代码里直接被支持，通常被翻译成底层处理器直接的支持。 System.IntPtr 和 System.UIntPtr 也是原始类型。 自定义类型 可以使用原始类型来构建复杂类型。 类型的成员： 数据成员 Data 函数成员 Function 构造函数和实例化 数据是通过实例化一个类型来创建的。 预定义的类型直接写 Literal 就可以被实例化了。 自定义类型通过 new 操作符来创建实例。 实例成员 vs 静态成员 操作于类型实例的数据成员和函数成员都叫做实例成员。 操作于类型而不是类型实例的数据成员和函数成员叫做静态成员。 static 静态类 static class 所有成员都是静态的。 静态类不可以创建实例。例如 Console，它在整个程序里就一个。 类型转换 C# 里互相兼容的类型实例间可以相互转换。 转换总是从现有的值创建出来一个新的值。 如果编译器可以断定转换肯定会失败，那么隐式和显式两种转换都会被禁止。 隐式转换 隐式转换是自动发生的。 隐式转换的两个必要条件： 编译器可以保证转换会成功。 信息不会有损失。 显式转换 显式转换需要手动进行。 显式转换的条件（任意一个成立）： 编译器不能保证转换会成功。 信息可能会有损失 值类型和引用类型 C# 类型分类 值类型 引用类型 泛型参数类型 指针类型 值类型 vs 引用类型 值类型包含所有的内置类型和自定义的结构体和枚举。 引用类型包含所有的类、数组、委托、接口类型，包括字符串。， 它们的根本区别在于处理内存的方式。 值类型 值类型变量/常量的内容就是一个值。 使用 struct 关键字可以创建自定义的值类型。 赋值： 值类型实例的赋值动作总是复制了该实例。 存储的开销： 值类型的实例所占的内存 = 其字段需要内存的总和 CLR 会把类型内的字段大小设置为该字段实际大小的整数倍。 引用类型 比值类型复杂 两个部分： 一个对象 到该对象的引用 引用类型的变量/常量的内容就是到一个含有值的对象的引用。 赋值： 给引用类型的变量赋值：复制引用，而不是对象实例，即浅拷贝。 允许多个变量引用同一个对象。（值类型没有这种可能） 存储的开销： 需依为引用和对象单独分配内存。 对象所占内存 = 其字段所占内存总和 + 额外的开销管理（最少 8 bytes） 每个对象的引用还需要额外的 4 或 8 个 bytes，（根据平台是 32 还是 64 位） 嵌套类型 嵌套类型就是声明在另一个类型作用范围内的类型。 TopLevel 被称为封闭类型。 嵌套类型的特性 可访问封闭类型的私有成员,以及任何封闭类型能访问的东西。 可以使用所有的访问修饰符来声明，不仅仅是 public 和 internal。 嵌套类型的默认访问级别是 private 而不是 internal。 从封闭类型外边访问嵌套类型需要使用的封闭类型的名称。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-types/"},{"title":"[真会C#?] - 泛型","content":"文档资料 泛型（C# 编程指南） 泛型为什么存在、类型参数、默认值等 泛型的作用 跨类型可复用的代码：继承和泛型。 继承 -&gt; 基类。 泛型 -&gt; 带有“（类型）占位符”的“模板”。 泛型类型 泛型会声明类型参数 - 泛型的消费者需要提供类型参数（arguments）来把占位符类型填充上。 Stack&lt;T&gt;： Open Type 开放类型。 Stack&lt;int&gt;： Closed Type 封闭类型。 在运行时，所有的泛型类型实例都是封闭的（占位符类型已被填充了） 为什么泛型会出现 不使用泛型实现 Stack 需要装箱和向下转换，这种转换在编译时无法进行检查。 泛型方法 泛型方法在方法的签名内也可以声明类型参数。 在泛型类型里面的方法，除非也引入（使用了&lt;T&gt;）了类型参数（type parameters），否则是不会归为泛型方法的。 只有类型和方法可以引入（使用了&lt;T&gt;）类型参数，属性、索引器、事件、字段、构造函数、操作符等都不可以声明类型参数，但是他们可以使用他们所在的泛型类型的类型参数。 声明类型参数 在声明 class、struct、interface、delegate 的时候可以引入（使用了&lt;T&gt;）类型参数（Type parameters）。 其他的例如属性，就不可以引入（使用了&lt;T&gt;）类型参数，但是可以使用类型参数。 泛型类型和泛型方法可以有多个类型参数。 泛型类型和泛型方法的名称可以被重载，条件是参数类型的个数不同。 按约定，泛型类型和花园泛型方法，如果只有一个参数类型，那么就叫 T。 当使用多个类型参数的时候，每个类型参数都使用 T 作为前缀，随后跟着具有描述性的一个名字，例如 &lt;Tkey, TValue&gt;。 typeof 与未绑定的泛型类型 开放的泛型类型在编译后就变成了封闭的泛型类型。 但是如果作为 Type 对象，那么未绑定的泛型类型在运行时是可以存在的。（只能通过 typeof 操作符来实现） 泛型的默认值 使用 default 关键字来获取泛型类型参数的默认值。 <!-- more --> 泛型约束、子类、自引用、静态数据、转换 泛型的约束 默认情况下，泛型的类型参数（parameter）可以是任何类型的。 如果只允许使用特定的类型参数（argument），就可以指定约束。 泛型的约束可以作用于类型或方法的定义。 泛型类型的子类 泛型类可以有子类，在子类里，可以继续让父类的类型参数保持开放。 在子类里，也可以使用具体的类型来封闭父类的类型参数。 子类型也可以引入新的类型参数。 技术上来讲，所有子类的类型参数都是新鲜的。你可以认为子类先把父类的类型参数（argument）给关闭了，然后又打开了。为这个先关闭后打开的参数（argument）带来新的名称或含义。 自引用的泛型声明 在封闭类型参数（argument）的时候，该类型可以把它自己作为具体的类型。 静态数据 针对每一个封闭类型，静态数据是唯一的。 类型参数和转换 C# 的转换操作符支持下列转换： 数值转换 引用转换 装箱拆箱转换 自定义转换 决定采用的是哪种转换，发生在编译时，根据已知类型的操作数来决定。 但是泛型在编译时不知道具体的类型，所以泛型转换会编译失败。 使用 as 操作符实现泛型转换。 或者使用装箱拆箱转换。 逆变、协变、不变 协变和逆变 通过的代码： 报错的代码： 因为 IList 中的一些方法操作 object 的时候是危险的。假如报错的代码成立，那么 具体错误：在 .Net 源码中，IEnumerable&lt;T&gt; 中的 T 只做返回类型使用。而 IList&lt;T&gt; 中的 T 既做返回又做输入参数。 还有一种 T 只做输入参数的泛型类型。下面的代码是成立的。 Covariance, Contravariance, Invariance Covariance 协变：当值作为返回值或 out 输出 IEnumerable&lt;string&gt; -&gt; IEnumerable&lt;object&gt; public interface IEnumerable&lt;out T&gt; 子类的 T 可以转换为父类的 T 有 &lt;out T&gt; 就是协变。 Contravariance 逆变：当值作为参数输入。 Action&lt;object&gt; -&gt; Action&lt;string&gt; public delegate void Action&lt;in T&gt; 父类的 T 可以转换为子类的 T 有 &lt;in T&gt; 就是逆变。 Invariance 不变：当值既是输入又是输出。 public interface IList&lt;T&gt; 既不能向上，也不能向下转换。 没有 out/in 修饰符的就是不变。 Variance 前面的协变、逆变、不变都称为 variance。 Variance 只能出现在接口和委托里。 Variance 转换时引用转换的一个例子。引用转换就是指，你无法改变其底层的值，只能改变实例的编译时的类型。 Identity conversion 本体转换：对 CLR 而言从一个类型转换到相同的类型。例如 object -&gt; dynamic 合理的转换 如果从 A 到 B 的转换是本体转换或者隐式引用转换，那么从 IEnumerable&lt;A&gt; -&gt; IEnumerable&lt;B&gt; 的转换就是合理的。 IEnumerable&lt;string&gt; -&gt; IEnumerable&lt;object&gt; IEnumerable&lt;string&gt; -&gt; IEnumerable&lt;IConvertible&gt; IEnumerable&lt;IDsposable&gt; -&gt; IEnumerable&lt;object&gt; 不合理的转换 IEnumerable&lt;object&gt; -&gt; IEnumerable&lt;string&gt; IEnumerable&lt;string&gt; -&gt; IEnumerable&lt;Stream&gt; IEnumerable&lt;int&gt; -&gt; IEnumerable&lt;IConvertible&gt; 虽然是隐式转换，但这是装箱操作而不是引用转换。 IEnumerable&lt;int&gt; -&gt; IEnumerable&lt;long&gt; 两个值类型，不是引用转换。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-generics/"},{"title":"[真会C#?] OOP - 接口","content":" 接口 什么是接口 接口和 class 类似，但是它只为其成员提供了规格，而没有提供具体的实现。 接口成员都是隐式抽象的。 一个类或者结构体可以实现多个接口。 接口的实现 接口的成员都是隐式公共的，不可以声明访问修饰符。 实现接口对它的所有成员进行 public 的实现： 默认接口方法 接口的扩展 接口可以继承其他接口 IRedoable 继承了 IUndoable 的所有成员。 显式接口的实现 实现多个接口的时候可能会造成成员签名的冲突。通过显式实现接口成员可以解决这个问题。 另一个显式实现接口成员的理由是故意隐藏那些对于类型来说不常用的成员。 virtual 实现接口成员 隐式实现的接口成员默认是 sealed 的，就是无法重写的。 如果想要进行重写的话，必须在基类中把成员标记为 virtual 或者 abstract。 显式实现的接口成员不可以被标记为 virtual，也不可以有通过寻常的方式来重写，但是可以对其进行重新实现。 在子类中重新实现接口 子类可以重新实现父类已经实现的接口成员。 重新实现会“劫持”成员的实现（通过转化为接口然后调用），无论在基类中该成员是否是 virtual 的。无论该成员是显式还是隐式的实现（但最好还是显式实现的）。 如果 TextBox 是隐式实现的 Undo 那么： 说明重新实现接口这种劫持只对转化为接口后的调用起作用，对转化为基类后的调用不起作用。 重新实现适用于重写显示实现的接口成员。 重新实现接口的替代方案（重点） 即使是显示实现的接口，接口的重新实现也可能有一些问题： 子类无法调用基类的方法。 基类的开发人员没有预料到方法会被重新实现，并且可能不允许潜在的后果。 最好的办法是设计一个无需重新实现的基类。 隐式实现成员的时候，按需标记 virtual。 显式实现成员的时候，可以这么做： 如果不想有子类，那么之境界把 class 给 sealed。 接口与装箱 把结构体转化为接口会导致装箱。 调用结构体上隐式实现的成员不会导致装箱。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-interface/"},{"title":"[真会C#?] OOP - 访问修饰符","content":"文档资料 真会C#？- 第3章 创建类型（完结，泛型部分单独出视频） C# 文档 访问修饰符 public：完全可访问。enum 和 interface 的成员默认都是整个级别。 internal：当前 assembly 或朋友 assembly 可访问，非嵌套类的默认访问级别。 private：本类可访问。class 和 struct 的成员的默认访问级别。 protected：本类或其子类可以访问。 protected internal：联合了 protected 和 internal 的访问级别。 朋友 Assembly 通过添加 System.Runtime.CompilerServices.InternalsVisibleTo 这个 Assembly 的属性，并指定朋友 Assembly 的名字，就可以把 internal 的成员暴露给朋友 Assembly。 如果朋友 Assembly 有 Strong name，那么就必须指定其完整的 160 字节的 public key。 朋友 Assembly 的使用场景是单元测试时。 访问级别限制 外层限制内层的最大访问范围。 当重写父类的函数时，重写后的函数和被重写的函数的访问级别必须一致。 有一个例外：当在其他 Assembly 重写 protected internal 的方法时，重写后的方法必须是 protected。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-modifier/"},{"title":"[真会C#?] OOP - 继承和多态","content":"继承、多态、引用转换、virtual 继承 一个类可以继承另一个类，从而对原有类进行扩展和自定义。 可以叫做子类和父类。 继承的类让你可以重用被继承类的功能。 C# 里一个类只能继承于另一个类，但是这个类却可以被多个类继承。换句话说，只能有一个亲爹（父类），多个干爹（接口），可以有多个儿子（子类）。 多态 多态就是使得你能够用一种统一的方式来处理一组各具个性却同属一族的不同个体的机制。 引用是多态的，类型为 x 的变量可以引用其子类的对象。 子类具有附类的全部功能特性，所以参数可以是子类。 反过来不行，因为子类可能具有父类没有的成员。 引用转换 一个对象的引用可以隐式的转换到其父类的引用（向上转换）。 想转换到子类的引用，则需要显示转换（向下转换）。 引用转换：创建了一个新的引用，它也指向同一个对象。 向上转换 从子类的引用创建父类的引用。 变量 parent 依然指向同一个 Child 对象（child 也指向它）。 尽管变量 parent 和 child 指向同一个对象，但是 parent 的可视范围更小一些。 向下转换 从父类的引用创建出子类的引用。 和向上转换一样，只涉及到引用,底层的对象不会受影响。 需要显示转换，因为可能会失败。 如如果向下转换失败，那么会抛出 InvalidCastException （属于运行时类型检查）。 as 操作符 as 操作符会直行，向下转换，如果转换失败，不会抛出异常，只会变成 null。 as 操作符无法做自定义转换。 is 操作符 is 操作符会检验应用的转换是否成功，换句话说，判断对象是否派生于某个类，或者实现了某个接口。 通常用于向下转换前的验证。 如果拆箱转换可以成功的话，那么使用 is 操作符的结果会是 true。 模式变量 C#7 里，在使用 is 操作符的时候，可以引入一个变量。 引用的变量可以立即使用。 Virtual 函数成员 虚拟成员的作用是实现多态性。 当调用一个对象的函数时，系统会直接去检查这个对象声明定义的类，即声明类，看所调用的函数是否为虚函数。 如果不是虚函数，那么它就直接执行该函数。而如果有 virtual 关键字，也就是一个虚函数，那么这个时候它就不会立刻执行该函数了，而是转去检查对象的实例类。 在这个实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过 override 关键字），如果有，则马上执行该实例类中的这个重新实现的函数。而如果没有，系统会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载了该虚函数的父类为止，然后执行该父类里重载后的函数。 标记为 virtual 的函数，可以被子类重写，包括方法、属性、索引器、事件。 使用 override 修饰符子类，可以重写父类的 virtual 函数。 virtual 方法和重写方法的签名、返回类型、可访问程度必须是一样的。 重写方法里使用 base 关键字可以调用父类的实现。 在构在构造函在构在构造函数里调用 virtual 方法可能比较危险，因为编写子类的开发人员可能不知道，他们在重写方法的时候面对的是一个未完全初始化的对象。 换句话说，重写的方法可能会访问依赖于还未被构造函数初始化的字段的属性或方法。 抽象、隐藏成员、new、sealed、base、初始化顺序等 抽象类和抽象成员 使用 abstract 的声明的类是抽象类。 抽象类不可以被实例化，只有其具体的子类才可以实体化。 抽象类可以定义抽象成员。 抽象成员和 virtual 成员很像，但是不提供具体的实现子类必须提供实现，除非子类也是抽象的。 抽象方法和虚拟方法的区别 对于抽象方法，子类必须实现它。 抽象方法中无法声明方法体 对于虚拟方法，子类可以重写也可以不重写。 虚拟方法必须实现方法体 因此，两者约束不同 隐藏被继承的成员 父类和子类可以定义相同的成员，但这不能实现多态。 B 类中的 Counter 字段就隐藏了 A 里面的 Counter 字段（通常是偶然发生的）。例如子类添加某个字段之后，父类也添加了相同的一个字段。 编译器会发出警告。 按照如下规则进行解析： 编译时对 A 的引用会绑定到 A.Counter。 编译时对 B 的引用会绑定到 B.Counter。 如果希望派生类具有与基类中的成员同名的成员，则可以使用 new 关键字隐藏基类成员。 new 关键字放置在要 替换的类成员的返回类型之前。 sealed 密封类 针对重写的成员，可以使用 sealed 关键字把它密封起来，防止他被其子类重写。 也可以 sealed 类本身，就隐式的 sealed 所有的 virtual 函数了。 base 关键字 base 和 this 略像，base 主要用于： 从子类访问父类里被重写的函数。 调用父类的构造函数。 这种写法可保证，访问的一定是 Asset 的 Liability 属性，无论该属性是被重写还是被隐藏了。 构造函数和继承 子类必须声明自己的构造函数。 从子类可访问父类的构造函数，但不是自动继承的。 子类必须重新定义它想要暴露的构造函数。 调用父类的构造函数需要使用 base 关键字。 父类的构造函数肯定会被优先执行。 隐式调用无参的父类构造函数 如果子类的构造函数里没有使用 base 关键字，那么父类的无参构造函数会被隐式的调用： 如果父类没有无参构造函数，那么子类就必须在构造函数里使用 base 关键字。 构造函数和字段初始化顺序 对象被实例化时，初始化动作安装如下顺序进行： 从子类到父类： 字段被初始化。 父类构造函数的参数值被算出。 从父类到子类： 构造函数体被执行。 重载和解析 例子： 重载方法被调用时，更具体的类型拥有更高的优先级： 调用哪个重载方法是在编译时就确定下来的。 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-inheritance-and-polymorphism/"},{"title":"[真会C#?] OOP - Class","content":"Class 最常见的一种引用类型 字段和方法 字段 Field 是类或结构体的成员，它是一个变量。 readonly readonly 修饰符防止字段在构造之后被改变。 readonly 字段只能在声明的时候被赋值，或在构造函数里被赋值。 字段初始化 字段可以可选初始化。 未初始化的字段有一个默认值。 字段的初始化在构造函数之前运行。 同时声明多个字段： Expression-Bodied 方法 方法的签名 类型内方法的签名必须唯一。 签名：方法名、参数类型（含顺序，但与参数名称和返回类型无关） 方法的重载 Overload 类型里的方法可以进行重载（允许多个同名的方法同时存在），只要这些方法的签名不同就行。 反例： 参数是按值传递还是按引用传递，也是方法签名的一部分。 构造函数与析构函数 构造函数 在 class 或 struct 上运行初始化代码。 和定义方法差不多，但构造函数的名和类型名一致，返回类型也和类型一致，并且返回类型就省略不写了。 C#7+ 允许单语句的构造函数写成 expression-bodied 成员的形式。 构造函数的重载 class 和 struct 可以重载构造函数，可以有多个构造函数。 一个构造函数调用另一个重载构造函数时使用 this。 当同一个类型下的构造函数 A 调用构造函数 B 时，B 先执行。 可以把表达式传递给另一个构造函数，但表达式本身不能使用 this 引用，因为这时候对象还没初始化，所以任何方法的调用都会失败。但是可以使用 static 静态方法。 无参构造函数 对于 class，如果你没有定义任何构造参数的话，那么 C# 编译器会自动生成一个无参 public 构造函数。 但是如果你定义了构造函数，那么这个无参构造函数就不会被生成了。 构造函数和字段的初始化顺序 字段的初始化发生在构造函数执行之前。 字段按照声明的先后顺序进行初始化。 非 public 构造函数 构造函数可以不是 public 的。 Deconstructor (C#7) C#7 引入了 deconstructor 模式 作用基本和构造函数相反，它会把反赋给一堆变量。 方法名必须是 Desconstruct，有一个或多个 out 参数。 Deconstruct 可以被重载。 Deconstruct 可以是扩展方法。 对象初始化、this、属性、索引器 对象初始化器 对象任何可访问的字段、属性在构建之后，可以使用对象初始化器直接为其进行设定值。 使用对象初始值设定项初始化对象 使用集合初始值设定项初始化字典 对象初始化器 vs 可选参数 如果不使用初始化器，上例中的构造函数也可以使用可选参数： 可选参数方式： 优点：可以让 Bunny 类的字段/属性只读。 缺点：每个可选参数的值都被嵌入到了 calling site，C# 会把构造函数的调用翻译成 Bunny b1 = new Bunny(&quot;Bo&quot;, true, false); this 引用 this 引用值得是实例的本身。 this 引用可以让你把字段与本地变量或参数区分开。 只有 class/struct 的非静态成员才可以使用 this。 属性 属性的声明 属性的声明和字段很像，但多了一个 get set 块。 使用属性 get 访问器会在属性被读取的时候运行，必须返回一个该属性类型的值。 set 访问器会在属性被赋值的时候运行，有一个隐性的该类型的参数 value，通常你会把 value 赋给一个私有字段。 属性与字段的区别 尽管属性的访问方式与字段的访问方式相同，但不同之处在于，属性赋予的实现者对获取和赋值的完全控制权。这种控制允许实践者选择任意所需的内部表示，不向属性的使用者公开其内部实现细节。 只读和计算的属性 如果属性只有 get 访问器，那么它是只读的。 如果只有 set 访问器，那么它是只写的（很少这样用）。 属性通常拥有一个专用的“幕后”字段（backing field），这个幕后字段用来存储数据。 Expression-bodied 属性 从 C#6 开始，你可以使用 Expression-bodied 形式来表示只读属性。 从 C#7，允许 set 访问器也可以使用该形式。 自动属性 属性最常见的一种实践就是：getter 和 setter 只是对 private field 进行简单直接的读写。 自动属性声明就告诉编译器来提供这种实现： 编译器会自动生成一个私有的幕后字段，其名称不可引用（由编译器生成）。 set 访问器也可以是 private 或 protected。 属性初始化器 从 C#6 开始，你可以为自动属性添加属性初始化器 只读的自动属性也可以使用（只读自动属性也可以在构造函数里被赋值）。 get 和 set 的访问性 get 和 set 访问器可以拥有不同的访问级别。 典型用法：public get, internal/private set 注意，属性的访问级别更“宽松”一些，访问器的访问级别更“严格”一些。 方法 通常有一些语句组成，会执行某个动作 参数 返回类型 void ref/out 索引器 索引器提供了一种可以访问封装的列表值或字典值的 class/struct 的元素的一种自然的语法。 语法很像使用数组实用的语法，但是这里的所有参数可以是任意类型的。 索引器和属性拥有同样的修饰符。 可以按照下列方式使用 null 条件操作符： 实现索引器 实现索引器需要定义一个 this 属性，并通过中括号指定参数。 使用索引器 多个索引器 一个类型可以声明多个索引器，它们的参数类型可以不同。 一个索引器可以有多个参数。 只读索引器 如果不写 set 访问器，那么这个索引器就是只读的。 在 C#6 以后，也可以使用 expression-bodied 的写法。 常量、静态构造函数和类、终结器、局部类和方法、nameof 常量 一个值不可以改变的静态字段。 在编译时值就已经定下来了。 任何使用常量的地方，编译器都会把这个常量替换为它的值。 常量的类型可以是内置的数值类型、bool、char、string或enum。 使用 const 关键字声明，声明的同时必须使用具体的值来对其初始化。 常量与静态只读字段 常量比静态只读字段更严格： 可使用的类型。 字段初始化的语义上。 常量是编译时进行值的估算的。 当值有可能改变，并且需要暴露给其他 Assembly 的时候，静态只读字段是相对较好的选择。 如果 Y Assembly 引用了 X Assembly 并且使用了这个常量，那么在编译的时候，2.3 这个值就会被固化于 Y Assembly 里。这意味着，如果后来 X 重编译了，这个常量变成了 2.4，如果 Y 不重新编译的话，Y 将仍然使用 2.3 这个值，直到 Y 被重新编译，它的值才会变成 2.4。静态只读字段就会避免这个问题的发生。 本地常量 方法里可以有本地的常量： 静态构造函数 静态构造函数用来初始化静态成员。 静态构造函数，每个类型执行一次。 非静态构造函数，每个实例执行一次。 一个类型只能定义一个静态构造函数。 必须无参 方法名与类型一致 在类型使用之前的一瞬间，编译器会自动调用类型的静态构造函数。 实例化一个类型。 访问类型的一个静态成员。 只允许使用 unsafe 和 extern 修饰符。 如果静态构造函数抛出了未处理的异常，那么这个类型在该程序的剩余生命周期内将无法使用了。 静态字段与静态构造函数的初始化顺序 静态字段的初始化器在静态构造函数被调用之前的一瞬间运行。 如果类型没有静态构造函数，那么静态字段初始化器在类型被使用之前的一瞬间执行，或者更早，在运行时突发奇想的时候执行。 静态字段的初始化顺序与他们的声明顺序一致。 静态类 类也可以是静态的。 其成员必须全是静态的。 不可以有子类。 例如 System.Console System.Math 析构函数（终结器） Finalizer 是 class 专有的一种方法。 在 GC 回收未引用对象的内存之前运行。 其实就是对 object 的 Finalize() 方法重写的一种语法。 分布类和方法 分布类 允许一个类型的定义分布在多个地方（文件）。 典型应用：一个类的一部分是自动生成的，另一部分需要手动写代码。 每个分布类都必须使用 partial 来声明。 下面这个列子会报错： 每个分布类的成员不能冲突，不能有同样参数的构造函数。 各分布类完全靠编译器来进行解析：每个分布类在编译时必须可用，并且在同一个 Assembly 里。 如果有父类，可以在一个或多个分布类上指明，但必须一致。 每个分布类可以独立的实现不同的接口。 编译器无法保证各分布类的字段的初始化顺序。 分布方法 分布类型可以有分布方法。 自动生成的分布类里可以有分布方法，通常作为“钩子”使用，在另一部分的分布方法里，我们可以对这个方法进行自定义。 分布方法由两部分组成：定义和实现。 定义部分通常是自动生成的。 实现部分通常是手动编写的。 如果分布方法只有定义，没有实现，那么编译的时候该方法就没有了，调用该方法的代码也没有了。这就允许自动生成的代码可以自由的提供钩子，不用担心代码膨胀。 分布方法必须是 void，并且隐式 private 的。 nameof 操作符 (C#6) nameof 操作符会返回任何符号（类型、成员、变量。。。）的名字（string 类型）。 利于重构 ","link":"https://www.kamasylvia.com/post/csharp-tutorial-class/"},{"title":"[真会C#?] - 基础语法","content":"文档资料 真会C#？- 第1-2章 简介和基础（完结） C# 文档 基础语法 命名准则 命名准则 标识符 identifier 标识符就是程序员给它们所写的类、方法、变量等起的名字。 标识符必须是一个完整的单词，它由 Unicode 字符组成，并且由字母或下划线开头。 关键字 关键字就是对编译器有特殊意义的一些名字。 大部分关键字都是保留的，意思是你不可以把它们当作标识符来使用。 如果非得用关键字当标识符 前面加一个 @ 上下文关键字 上下文关键字用于在代码中提供特定含义，但不是 C# 中的保留字。一些上下文关键字（如 partial 和 where）在两个或多个上下文中有特殊含义。 Literal，标点符号，操作符 注释 单行注释，通常开头加空格：// ... 多行注释，通常开头结尾加空格：/* ... */ ","link":"https://www.kamasylvia.com/post/csharp-tutorial-basic/"},{"title":"[Config] ZSH Config File (.zshrc)","content":" ","link":"https://www.kamasylvia.com/post/zsh-config-file/"},{"title":"[摄影] 富士胶片模拟","content":"XT-20 Provia 万能 Agfa Optima [Agfa Optima](https://fujixweekly.com/2020/03/22/fujifilm-x-t1-agfa-optima-provia-film-simulation-recipe/) Analog Cool [Analog Cool](https://fujixweekly.com/2020/09/22/fujifilm-x-t200-bayer-film-simulation-recipe-analog-cool/) Velvia 艳丽 Velvia [Velvia](https://fujixweekly.com/2020/10/20/fujifilm-x-m1-x-trans-i-film-simulation-recipe-vivid-color/) Lomography Color 100 [Lomography Color 100](https://fujixweekly.com/2020/07/22/fujifilm-xq1-x-trans-ii-film-simulation-recipe-lomography-color-100/) Ektachrome 100SW [Ektachrome 100SW](https://fujixweekly.com/2020/02/17/fujifilm-x-t1-x-trans-ii-ektachrome-100sw-film-simulation-recipe/) Astia 柔和 Astia 万能 [Astia 万能](https://fujixweekly.com/2020/08/22/fujifilm-x-trans-ii-film-simulation-recipe-astia/) Classic Chrome 复古 Kodak Portra 800 [Kodak Portra 800](https://fujixweekly.com/2020/11/03/fujifilm-x100v-film-simulation-recipe-kodak-portra-800/) Kodak Portra 160 [Kodak Portra 160](https://fujixweekly.com/2020/03/29/not-my-fujifilm-x-t1-x-trans-ii-kodak-portra-160-film-simulation-recipe/) Bright Summer [Bright Summer](https://fujixweekly.com/2020/09/12/fujifilm-x100v-film-simulation-recipe-preet/) Classic Negative Agfa [Agfa](https://fujixweekly.com/2020/09/28/fujifilm-x100v-film-simulation-recipe-agfa-vista-100/) PRO Neg. Std 负片 Porto 200 秋意 [Porto 200 秋意](https://fujixweekly.com/2020/10/27/fujifilm-x-t1-x-trans-ii-film-simulation-recipe-porto-200/) 富士胶片模拟表 ","link":"https://www.kamasylvia.com/post/fujixweekly/"},{"title":"[.Net] .Net 解析 JSON","content":"引言 目前解析 JSON 用的库主流有两种，System.Text.Json 和 Json.Net 其中 System.Text.Json 是官方库，但还很不成熟。Json.Net 虽然是第三方库但也有官方背书，在 Asp.Net 官方模板中是直接引入的，功能完备项目成熟。本篇记录一下 Json.Net 的使用方法。 准备工作 首先我们准备一份复杂嵌套的 .json 文件，比如 events.json。 读取文件 这里读取文件采用的是 File.ReadAllText，因为要一次性读取所有内容。 反序列化 取出的数据可以向 python 那样操作 数据类型有 JArray、JObject、JProperty。 类型转换 JProperty 和 JObject 类型使用 ToObject&lt;T&gt;() 转换成 .Net 类型 JArray 类型需要使用 Linq，参考官方示例。 序列化 写入文件 ","link":"https://www.kamasylvia.com/post/dotnet-json/"},{"title":"[Git] Mozilla Development Flow","content":"WSL2 Debian/Ubuntu Build Firefox Mercurial Overview Firefox Contributors' Quick Reference Artifact Mode If you are not working on the C/C++ files you can also opt for Artifact Builds which are much faster. To enable artifact build set up a .mozconfig file with the following options: If you plan to walk through code with a debugger, set up a .mozconfig file with the following options: --- Linux build preparation Perftest Notebook New Contributors to Perftest Test Linter: ./mach lint --warnings --outgoing Unit Test:: ./mach perftest-test or ./mach perftest-test -s Debug Run: ./mach perftest python/mozperftest/mozperftest/tests/example.js Version Contral by Mercurial Pull: hg pull --verbose https://hg.mozilla.org/mozilla-central/ Commit: Using VSCode Extension. Changes: Using VSCode Extension. Amend: hg commit --amend Check the current and latest revisions: hg head or hg heads Update: hg up -r &lt;revision&gt; Rebase: hg rebase -r &lt;current_revision&gt; --dest &lt;latest_revision&gt; Submit: moz-phab (Make sure MozPhab is installed by pip3) ","link":"https://www.kamasylvia.com/post/mozilla-development-flow/"},{"title":"[Game] How To Make C# Discord Bot","content":"前言 此文是跟着视频 How To Make C# Discord Bot 学习时需要注意的地方，主要是使用新方案替代视频中已经不可用的旧方案。 How To Make A C# Discord Bot - Setting Up - Part 1 CommandsNextModule -&gt; CommandsNextExtension 在定义 Config 对象时，使用 DTO class 替代视频中的 struct。 使用 dotnet core 3.0+ 自带的 System.Text.Json 替代 Newtonsoft.Json ","link":"https://www.kamasylvia.com/post/how-to-make-csharp-discord-bot/"},{"title":"[Tools] 工具箱","content":"Documents Google Docs Vizzlo 画图工具 Notebook 替代Evernote免费开源笔记Joplin-网盘同步笔记历史版本Markdown可视化 Joplin Password Manager Bitwarden自建密码存储系统图文教程-开源免费的bitwarden_rs安装与使用 AI AI写论文-小论文神器 AI检查英语作文-微软小英爱写作 AI智能原创-5118大数据平台 AI写自媒体稿子-Giiso写作机器人 AI写诗-九歌 AI作画-自动给画上色 AI无损放大图片 AI写对联-微软对对联 AI生成照片-高颜值人脸AI生成器 Windows Terminal Themes Windows Terminal Themes ","link":"https://www.kamasylvia.com/post/tools/"},{"title":"[Python] Python 中创建 const 常量","content":"前言 Python 没有 const 关键字，想要创建常量只能自己想办法。 这篇笔记介绍的是使用私有变量、单例模式、只读属性和不可变类型创建一个 Constant 类，在其中储存和调用所需要的常量值。 私有变量[1] 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 __，在Python中，实例的变量名如果以 __ 开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 单例模式[2] 只读属性[3] Python 中的属性[4]和 C# 中的属性是同一个概念。 那么如何将一个普通的方法转换为一个“伪装”的属性呢？ 首先，在普通方法的基础上添加 @property 装饰器，例如上面的 age() 方法。这相当于一个 get 方法，用于获取值,决定类似 result = obj.age 执行什么代码。该方法仅有一个 self 参数。 写一个同名的方法，添加 @xxx.setter 装饰器（xxx表示和上面方法一样的名字），比如例子中的第二个方法。这相当于编写了一个 set 方法，提供赋值功能，决定类似 obj.age = .... 的语句执行什么代码。 再写一个同名的方法，并添加 @xxx.delete 装饰器，比如例子中的第三个方法。用于删除功能，决定 del obj.age 这样的语句具体执行什么代码。 简而言之，就是分别将三个方法定义为对同一个属性的获取、修改和删除。还可以定义只读属性，只需要使用 @property 声明 get 方法，不定义 setter 方法就是一个只读属性。 不可变类型 常量是不可变类型的子集，区别在于不可变类型的变量名可以重新绑定到其他类型上，而常量名和常量值都是不可变的。 不可变字典 可变类型 list 和 set 对应的不可变类型分别为 tuple 和 frozenset。但在 PEP 416 中拒绝了不可变字典的要求。因此我们使用 Python 3.3 中引入的 MappingProxyType 和私有变量搭配实现不可变字典的返回。 使用常量 Constant 是一个类，所以我们需要先实例化才能使用它。 廖雪峰的 Python 教程 ↩︎ Python单例模式(Singleton)的N种实现 ↩︎ python @property 设置只读属性 重写 getter setter 方法 ↩︎ 刘江的博客教程 ↩︎ ","link":"https://www.kamasylvia.com/post/create-constant-in-python/"},{"title":"[Black Desert] 黑色沙漠M 导入韩服捏脸数据","content":"模拟器 夜神、雷电、蓝叠 安装 ES File Explore 直接 Google Play 下载 下载 QooApp 并安装 模拟器中的浏览器搜索 QooApp, 官网不一定下得到，可以从第三方下载 安装黑沙 QooApp 中搜索 black desert mobile，日韩台服都有 运行黑沙 墙外无任何困难 按作者搜索捏脸作品 需要复制作者姓名，如果是韩语并且是图片，使用 OCR 工具 导出/导入 捏脸数据 关闭游戏，关闭模拟器。 克隆备份模拟器。 在备份模拟器中开游戏。 导出捏脸数据。 关闭韩服。 打开美服，进入角色捏脸界面，右上角缓存一下建立缓存文件。 打开 ES File Explorer。 root 权限打开，导出的数据在/data/data/com.pearlabyss.blackdesertm/files/res/customization文件夹。第二个data文件夹可能会变动。 同样复制一份数据到 /mnt/shared/Pictures。 通过模拟器与 PC 共享文件，导出数据到 PC 以作备份。 将所需要的数据黏贴到/data/data/com.pearlabyss.blackdesertm.gl/files/res/customization。 打开美服，载入数据。 如果失败，调用备份模拟器和数据。 参考 【攻略】韓版、台版捏臉數據導出教學(圖多) 12/6修改 ","link":"https://www.kamasylvia.com/post/bdm-beauty-transfer/"},{"title":"[Black Desert] 黑色沙漠M 美服 Heidel 华人公会","content":"Discord 手动加入 discord.gg/pj5YEDj 或者点击 这里 微信群 公会每日任务[1] 鸣谢 工会成员 FenrirWolf 制作的工会每日任务教程。 ↩︎ ","link":"https://www.kamasylvia.com/post/bdm-na-guild/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... <!-- more --> Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://www.kamasylvia.com/post/hello-gridea/"}]}